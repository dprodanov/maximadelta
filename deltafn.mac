/*
 * (C) Dimiter Prodanov
 *
 * @version 1.2.5 Date 17 Aug 2014
		   1.2 Data 28 June 2014 
 *		   1.1 Date 29 April 2014
 *
 * @author Dimiter Prodanov
 * 		  IMEC

 * @contents
 * This library implements Diracs's delta function
 * 
 * @license This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
deltainfo([_package]):=
block(
	disp("package name: deltafn.mac (c)"),
	disp("author: Dimiter Prodanov"),
	disp("major version: 1"),
	disp("minor version: 2"),
	disp("Recommended location: share/contrib"),
	disp("last update: 29 June, 2014"),
	disp("")
)$
 
 declare (delta, evenfun)$
 
 if get('deltafn,'version)=false then ( 
	_macheps():=block ( [macheps],
	macheps:1.0,
	while not equal(float(1.0 + macheps/2.0), 1.0) do (
		macheps : float(macheps/2.0)
	),
	return (macheps)
	),
	_epsilon: _macheps()
 )$
 
 ( "basic infinitesimals",
	assume(zeroa > 0),
	assume(zerob < 0),
	assume(zeroa < _epsilon),
	assume(zerob >- _epsilon),
	declare(infinitesimal, feature),
	declare(zeroa, infinitesimal),
	declare(zerob, infinitesimal),
	infimp(x):= featurep (x, infinitesimal),
	"basic unlimited",
	declare(unlimited, feature),
	unlimp(x):= featurep (x, unlimited)
 )$
 


/*  
tellsimp(delta(u), _delta(u)) 
_delta(u):= block(
if (u#0 and u # 0.0 and u # zeroa and u # zerob) then 0 
else 1/zeroa) $
*/

_delta(x):= block(
	if infimp(x) or abs(x)<=zeroa then return (1/zeroa/2) 
	else return (0) 
 )$

_unit(x):= (
	if x<0 then (0) else 
	if x>0 then (1)  
	else (1/2)
)$
 
(matchdeclare (x, atom),
	defrule (ddev1, delta(x), _delta(x)),
	defrule (ddunit, unit(x), _unit(x))
 )$
 
(matchdeclare (x, lambda([u], not(constantp(u))), c, atom),
	defrule (ddscale, delta(c*x), 1/abs(c)*delta(x))
 )$
 
/* shifting rules 
 */
(matchdeclare (u, lambda([u], not(constantp(u)) and atom(u)), z, atom, c, constantp),
	defrule (ddint1, 'integrate(delta(z-u), u ), unit(z)),
	defrule (ddint11, 'integrate(delta(c-u), u ), unit(c)),
	"defrule (ddint1, 'integrate(delta(z-u), u ), z)",
	"defrule (ddint10, 'integrate(delta(z+u), u ), -z)"
)$

/* function rules 
 */
(matchdeclare (u, lambda([u], not(constantp(u)) and atom(u)), z, atom, c, constantp, fn, true),
	defrule (ddint3, 'integrate(delta(z-u)*fn(u), u, minf, inf), fn(z))
)$

/*
matchdeclare (aa, all, xx, symbolp);
simp : false;
defrule (r1, 'integrate(delta(xx)*aa, xx, minf, inf), subst (xx = 0, aa));
simp : true;
*/

(matchdeclare (aa, all, xx, symbolp), 
	simp : false,
	defrule (ddint2, 'integrate(delta(xx)*aa, xx, minf, inf), subst (xx = 0, aa)),
	simp : true
)$


(matchdeclare (u, lambda([u], not(constantp(u)) and atom(u)), z, atom, c, constantp, fn, symbolp, n, intvalp),
	"defrule (ddint2, 'integrate(delta(z-u)*fn(u), u), fn(z))",
	"defrule (ddint21, 'integrate(delta(u)*fn(u), u), fn(0))",
	defrule (ddint22, 'integrate(delta(z-u)*'diff (fn(u), u, n), u), diff(fn(z), z, n) ),
	defrule (dderiv2, 'integrate('diff(delta(u), u, n)*fn(u), u), - 'integrate('diff(delta(u), u, n-1)*diff (fn(u), u, 1), u) ),
	defrule (dderiv21, 'integrate('diff(delta(z-u), u, n)*fn(u), u), - 'integrate('diff(delta(z-u), u, n-1)*diff (fn(u), u, 1), u) ),
	defrule (dderiv23, 'integrate('diff(delta(z-u), u, n)*fn(u), u), (- 1)^n * 'integrate(delta(z-u)*diff (fn(u), u, n), u) )
)$

(matchdeclare (x, atom, n, intvalp),
	defrule (ddint3, 'integrate(delta(x), x), unit(x)),
	defrule (ddint4, 'integrate(delta(x), x, -inf, inf ), 1),
	defrule (dderiv1, 'diff(delta(x), x, n), 1/(-x)^n *delta(x)*factorial (n) )
)$

intvalp(x):= integerp(x) or featurep(x, integer)$

(matchdeclare ([%darg, %deltam], true),
defmatch (ddarg, %deltam*delta (%darg))
)$

(matchdeclare (V, lambda([x], not atom (x) and not listp(x) and not constantp(x) ), u, atom, fn, symbolp),
	defrule (dderiv3, delta(V), fdroot2(V)),
	defrule (dderiv4, delta(fn(u)), fdroot(fn(u), u))
)$

fdroot(V, x):=block( [rts, n, i:1, s:0, dfn, sd, xi ],
	rts:solve(V=0,x),
	if emptyp(rts) then return (delta(V))
	else (
		n:length(rts),
		dfn:diff (V, x),
		for i:1 thru n do (
			xi:part(rts[i],2),
			sd:subst(x=xi, dfn), "print (xi, dfn, sd)",
			if (sd #0) then
				s:s+delta(x-xi)/abs(sd)
			else s: delta(V)
		),
		return (s)
	)
)$ 

fdroot2(V):=block ( [ vl: listofvars (V), v ] ,
	if length(vl)>1 then return (delta(V)),
	v:vl[1],
	return (fdroot(V, v))
)$


delta_rules : sublist (rules, lambda ([a], smismatch ("dd", sconcat (a)) = 3 and 
(a # 'ddev1 and a # 'ddunit )))$

simp_delta(x):=apply(apply1, cons('x, delta_rules))$

eval_delta(x):=apply1(x, ddev1, ddunit)$

put('deltafn, 1.2, 'version);
put('deltafn, "Dimiter Prodanov", 'author);
put('deltafn, "(C) - Dimiter Prodanov, 2014", 'copyright);